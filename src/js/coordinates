
  getHeliocentricCoordinatesFromElements(elements) {
    let x, y, z, heliocentricCoordinates;
    x = elements.semiMajorAxisAu * (Math.cos(elements.eccentricAnomalyDegrees) - elements.eccentricityRadians);
    y = elements.semiMajorAxisAu * Math.sqrt(1 - Math.pow(elements.eccentricityRadians, 2));
    z = 0;
    heliocentricCoordinates = new Vector3(x, y, z);
    return heliocentricCoordinates;
  }
  getEclipticCoordinatesFromHeliocentricCoordinates(elements, heliocentricCoordinates) {
    let x, y, z, eclipticCoordinates;
    let cosPerihelion = Math.cos(elements.periapsisLongitudeDegrees);
    let sinPerihelion = Math.sin(elements.periapsisLongitudeDegrees);
    let cosAscending = Math.cos(elements.ascendingNodeLongitudeDegrees);
    let sinAscending = Math.sin(elements.ascendingNodeLongitudeDegrees);
    let cosInclination = Math.cos(elements.inclinationDegrees);
    let sinInclination = Math.sin(elements.inclinationDegrees);

    x = (
      (cosPerihelion * cosAscending) - (sinPerihelion * sinAscending * cosInclination) * heliocentricCoordinates.x
    ) + (
      (-sinPerihelion * cosAscending) - (cosPerihelion * sinAscending * cosInclination) * heliocentricCoordinates.y
    );

    y = (
      (cosPerihelion * sinAscending) + (sinPerihelion * cosAscending * cosInclination) * heliocentricCoordinates.x
    ) + (
      (-sinPerihelion * sinAscending) + (cosPerihelion * cosAscending * cosInclination) * heliocentricCoordinates.y
    );

    z = (
      (sinPerihelion * sinInclination) *  heliocentricCoordinates.x
    ) + (
      (cosPerihelion * sinInclination) * heliocentricCoordinates.y
    );

    eclipticCoordinates = new Vector3(x, y, z);
    return eclipticCoordinates;
  }
  getJ2000CoordinatesFromEclipticCoordinates(currentElements, eclipticCoordinates) {
    let x, y, z, j2000Coordinates;
    let obliquity = 23.43928;
    let sinOb = Math.sin(obliquity);
    let cosOb = Math.cos(obliquity);
    x = eclipticCoordinates.x;
    y = (cosOb * eclipticCoordinates.y) - (sinOb * eclipticCoordinates.z);
    z = (sinOb * eclipticCoordinates.y) + (cosOb * eclipticCoordinates.z);
    j2000Coordinates =  new Vector3(x, y, z);
    return j2000Coordinates;
  }
  getPositionAtCenturiesPastJ2000(currentCenturiesPastJ2000) {
    let currentElements, heliocentricCoordinates, eclipticCoordinates, j2000Coordinates, x, y, z, position;
    if (this.star) {
      x = 0;
      z = 0;
      z = 0;
    } else {
      currentElements = this.getKeplerianElementsAtCenturiesPastJ2000(currentCenturiesPastJ2000);
      heliocentricCoordinates = this.getHeliocentricCoordinatesFromElements(currentElements);
      eclipticCoordinates = this.getEclipticCoordinatesFromHeliocentricCoordinates(currentElements, heliocentricCoordinates);
      j2000Coordinates = this.getJ2000CoordinatesFromEclipticCoordinates(currentElements, eclipticCoordinates);
      x = j2000Coordinates.x * this.orbit.radius;
      y = j2000Coordinates.y * this.orbit.radius;
      z = j2000Coordinates.z * this.orbit.radius;
    }
    position = new Vector3(x, y, z);
    return position;
  }
